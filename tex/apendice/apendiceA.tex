\begin{apendicesenv}
\appendix
\chapter{Arquivo sha256.h}\label{apendice:sha256_h}
\begin{lstlisting}[language=C]
#ifndef SHA256_H
#define SHA256_H

#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>

// Tipos
#define uchar unsigned char // 8-bit byte
#define uint uint32_t 

// Macro para tratar adicao de inteiros de 64 bits
#define DBL_INT_ADD(a,b,c) if (a > 0xffffffff - (c)) ++b; a += c;

// Macros para rotacoes
#define ROTLEFT(a,b) ((uint32_t)(((uint64_t)(a) << (b)) | ((uint64_t)(a) >> (32 - (b)))))
#define ROTRIGHT(a,b) ((uint32_t)(((uint64_t)(a) >> (b)) | ((uint64_t)(a) << (32 - (b)))))


static inline uint32_t rotr32(uint32_t value, uint32_t shift) {
 shift &= 31;
 return ((value >> shift) | ((value << (32 - shift)) & 0xFFFFFFFF));
}

// Macros para funcoes logicas do SHA-256
#define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))
#define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
#define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
#define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
#define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))

// Constantes do SHA-256
static const uint k[64] = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

void sha256_transform(uint state[8], const uchar data[64]);
void sha256_init(uint state[8]);
void sha256_update(uchar in_data[64], uint *datalen, uint bitlen[2], const uchar header[80], uint len, uint state[8]);
void sha256_final(uchar in_data[64], uint *datalen, uint bitlen[2], uint state[8], uchar final_hash[32]);

void sha256_top(
  uint32_t *header,          // 80 bytes = 20 palavras
  uint32_t *hash_result,     // 32 bytes = 8 palavras
  volatile bool *ap_busy_out // 'true' quando computando, 'false' quando ocioso
);
#endif // SHA256_H
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Arquivo sha256.c} \label{apendice:sha256_c}

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdbool.h>
#include "sha256.h"

/*Recebe um bloco de 64 bytes (512 bits) como data[]
Expande esse bloco para 64 palavras de 32 bits (m[64])
Aplica os 64 rounds do algoritmo SHA-256 usando as constantes k[]
Atualiza state[8] com o resultado final acumulado*/
void sha256_transform(uint state[8], const uchar data[64]) {
  uint a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];
  #pragma HLS ARRAY_PARTITION variable=data complete dim=1
  #pragma HLS ARRAY_PARTITION variable=m complete dim=1

  for (i = 0, j = 0; i < 16; ++i, j += 4) {
    #pragma HLS unroll
    m[i] = (data[j] << 24) | (data[j+1] << 16) | (data[j+2] << 8) | (data[j+3]);
  }

  for (; i < 64; ++i)  {
    #pragma HLS PIPELINE II=1
    m[i] = SIG1(m[i-2]) + m[i-7] + SIG0(m[i-15]) + m[i-16];
  }

  a = state[0];
  b = state[1];
  c = state[2];
  d = state[3];
  e = state[4];
  f = state[5];
  g = state[6];
  h = state[7];

  for (i = 0; i < 64; ++i) {
    #pragma HLS pipeline II=1
    t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i];
    t2 = EP0(a) + MAJ(a, b, c);
    h = g;
    g = f;
    f = e;
    e = d + t1;
    d = c;
    c = b;
    b = a;
    a = t1 + t2;
  }

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
  state[4] += e;
  state[5] += f;
  state[6] += g;
  state[7] += h;
}

/*Inicializa o vetor state[8] com os valores padrao do SHA-256, conforme a especificacao (FIPS 180-4).
Isso prepara o estado inicial para o hashing.*/
void sha256_init(uint state[8]) {
  #pragma HLS inline
  state[0] = 0x6a09e667;
  state[1] = 0xbb67ae85;
  state[2] = 0x3c6ef372;
  state[3] = 0xa54ff53a;
  state[4] = 0x510e527f;
  state[5] = 0x9b05688c;
  state[6] = 0x1f83d9ab;
  state[7] = 0x5be0cd19;
}

/*Vetor de entrada (header[]) e seu tamanho (len)
Buffer interno in_data[64] (para armazenar dados parciais)
datalen acumulado no buffer atual
comprimento total (bitlen[2])
E state[8] do hash em progresso*/
void sha256_update(uchar in_data[64], uint *datalen, uint bitlen[2], const uchar header[], uint len, uint state[8]) {
  for (uint i = 0; i < len; ++i) {
    in_data[*datalen] = header[i];
    (*datalen)++;
    if (*datalen == 64) {
      sha256_transform(state, in_data);
      DBL_INT_ADD(bitlen[0], bitlen[1], 512);
      *datalen = 0;
    }
  }
  DBL_INT_ADD(bitlen[0], bitlen[1], (*datalen) * 8);
}




/*padding SHA-256 (bit 1, zeros ate completar 56 bytes)
codificacao do tamanho da mensagem (bitlen) nos ultimos 8 bytes
Se ainda tiver dados no buffer (in_data), processa com sha256_transform
Extrai os 8 valores de state[8] e transforma em final_hash[32] (Big Endian)*/
void sha256_final(uchar in_data[64], uint *datalen, uint bitlen[2], uint state[8], uchar final_hash[32]) {
  uint i, j;
  i = *datalen;  
  // Padding
  if (*datalen < 56) {
    in_data[i++] = 0x80;
    while (i < 56) in_data[i++] = 0x00;
  } else {
    in_data[i++] = 0x80;
    while (i < 64) in_data[i++] = 0x00;

    sha256_transform(state, in_data);

    // Zera e prepara novo bloco
    for (j = 0; j < 56; j++) in_data[j] = 0;
    i = 56;
  }
  in_data[63] = bitlen[0];
  in_data[62] = bitlen[0] >> 8;
  in_data[61] = bitlen[0] >> 16;
  in_data[60] = bitlen[0] >> 24;
  in_data[59] = bitlen[1];
  in_data[58] = bitlen[1] >> 8;
  in_data[57] = bitlen[1] >> 16;
  in_data[56] = bitlen[1] >> 24;

  sha256_transform(state, in_data);

  // Para converter de Big Endian (state[0]) para Little Endian (final_hash)
  sha256_final_final_loop:
  for (i = 0; i < 4; ++i) {
    #pragma HLS UNROLL
    final_hash[i]     = (state[0] >> (24 - i * 8)) & 0xff;
    final_hash[i + 4] = (state[1] >> (24 - i * 8)) & 0xff;
    final_hash[i + 8] = (state[2] >> (24 - i * 8)) & 0xff;
    final_hash[i +12] = (state[3] >> (24 - i * 8)) & 0xff;
    final_hash[i +16] = (state[4] >> (24 - i * 8)) & 0xff;
    final_hash[i +20] = (state[5] >> (24 - i * 8)) & 0xff;
    final_hash[i +24] = (state[6] >> (24 - i * 8)) & 0xff;
    final_hash[i +28] = (state[7] >> (24 - i * 8)) & 0xff;
  }
}
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Arquivo sha256\_top.c}\label{apendice:sha256_top_c}
\begin{lstlisting}[language=C]
#include "sha256.h"


void sha256_top(
  uint32_t header[20],       // 80 bytes = 20 palavras
  uint32_t hash_result[8],   // 32 bytes = 8 palavras
  volatile bool *ap_busy_out // 'true' quando computando, 'false' quando ocioso
){
  #pragma HLS INTERFACE s_axilite port=header      bundle=control offset=0x100
  #pragma HLS INTERFACE s_axilite port=hash_result bundle=control offset=0x200
  #pragma HLS INTERFACE s_axilite port=return      bundle=control

  #pragma HLS INTERFACE ap_none    port=ap_busy_out

  unsigned char hash1[32];
  unsigned char hash2[32];
  unsigned char header_bytes[80];

  #pragma HLS ARRAY_PARTITION variable=hash1        complete dim=1
  #pragma HLS ARRAY_PARTITION variable=hash2        complete dim=1
  #pragma HLS ARRAY_PARTITION variable=header_bytes complete dim=1
  
  #pragma HLS DEPENDENCE      variable=header       inter false
  #pragma HLS DEPENDENCE      variable=hash_result  inter false

    *ap_busy_out = true;  // Ativa o sinal de ocupado assim que a funcao comeca a ser executada no hardware.

  // Converte header (uint32_t[20]) para bytes
  for (int i = 0; i < 20; i++) {
    #pragma HLS UNROLL
    header_bytes[i*4 + 0] = (header[i] >>  0) & 0xFF;
    header_bytes[i*4 + 1] = (header[i] >>  8) & 0xFF;
    header_bytes[i*4 + 2] = (header[i] >> 16) & 0xFF;
    header_bytes[i*4 + 3] = (header[i] >> 24) & 0xFF;
  }

  // Zera temporarios
  for (int i = 0; i < 32; i++) hash1[i] = 0;
  for (int i = 0; i < 32; i++) hash2[i] = 0;
  
  uchar in_data[64] = {0};
  uint datalen = 0;
  uint bitlen[2] = {0};
  uint state[8] = {0};

  // SHA256 ROUND 1
  sha256_init(state);
  sha256_update(in_data, &datalen, bitlen, header_bytes, 80, state);
  sha256_final(in_data, &datalen, bitlen, state, hash1);

  for (int i = 0; i < 64; i++) in_data[i] = 0;
  datalen = 0;
  bitlen[0] = 0;
  bitlen[1] = 0;

  // SHA256 ROUND 2
  sha256_init(state);
  sha256_update(in_data, &datalen, bitlen, hash1, 32, state);
  sha256_final(in_data, &datalen, bitlen, state, hash2);


  // Converte hash2 (bytes) para hash_result (uint32_t[8])
  for (int i = 0; i < 8; i++) {
    #pragma HLS UNROLL
    hash_result[i] = ((uint32_t)hash2[i*4 + 3] << 24) |
                     ((uint32_t)hash2[i*4 + 2] << 16) |
                     ((uint32_t)hash2[i*4 + 1] << 8)  |
                     ((uint32_t)hash2[i*4 + 0]);              
  }

  *ap_busy_out = false;  // Desativa o sinal de ocupado quando a computacao principal termina.


}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Arquivo cycle\_counter.vhdl}\label{apendice:cycle_counter}

\begin{lstlisting}[language=vhdl]
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity cycle_counter is
  Port (
    clk           : in  std_logic;
    reset         : in  std_logic;
    ap_busy_in    : in  std_logic;
    cycle_count   : out std_logic_vector(31 downto 0)
  );
end cycle_counter;

architecture Behavioral of cycle_counter is
  signal counter    : unsigned(31 downto 0) := (others => '0');
  signal reg_out    : unsigned(31 downto 0) := (others => '0');
  signal prev_ap_busy : std_logic := '0'; -- Para detectar transicao de 'ocioso' a 'ocupado'
begin
  process(clk)
  begin
    if rising_edge(clk) then
      if reset = '0' then
        counter   <= (others => '0');
        reg_out   <= (others => '0');
        prev_ap_busy <= '0';
      else
        if prev_ap_busy = '0' and ap_busy_in = '1' then
          counter <= (others => '0'); -- Reseta o contador ao iniciar a computacao
          -- prev_ap_busy = '0' e ap_busy_in = '1' detecta a borda de subida.
        elsif ap_busy_in = '1' then -- Enquanto o IP esta ocupado (ap_busy_in e '1')
          counter <= counter + 1;
        elsif prev_ap_busy = '1' and ap_busy_in = '0' then
          -- Detecta o fim da execucao (ap_busy_in vai de '1' para '0')
          reg_out <= counter; -- valor final quando a computacao termina
        end if;
        prev_ap_busy <= ap_busy_in; -- Atualiza ap_busy_in para a proxima deteccao de borda
      end if;
    end if;
  end process;
  cycle_count <= std_logic_vector(reg_out);
end Behavioral;
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Arquivo main.c}\label{apendice:main_c}

\begin{lstlisting}[language=C]
#include "xil_io.h"
#include "xparameters.h"
#include "xil_printf.h"
#include "xtime_l.h"

#include <stdio.h> // para getchar(), fgets
#include <string.h>
#include "sha256.h"

// Base address do IP sha256_top_0 (mapeado via Address Editor)
#define SHA256_BASE       0xA0000000            // s_axi_control
#define GPIO_BASE         0xA0010000            // Enderecos para o AXI GPIO

#define CYCLE_COUNT_READ  (GPIO_BASE + 0x0)     // Data register para leitura do contador
#define REG_CONTROL       (SHA256_BASE + 0x00)  // Controle (ap_start, ap_done, ap_idle, etc.)
#define REG_HEADER_BASE   (SHA256_BASE + 0x100) // Offset inicial para os 20 registros de entrada (uint32_t[20])
#define REG_RESULT_BASE   (SHA256_BASE + 0x200) // Offset inicial para os 8 registros de saida (uint32_t[8])
#define CLOCK_HZ	      250000000ULL          // Para clock em 250 MHz no PL


// Variaveis globais
uint32_t header[20];       // 80 bytes
uint32_t hash_result[8];   // 32 bytes
u64 nanos_cpu, nanos_fpga;
u64 hashrate_cpu, hashrate_fpga;
int match_cpu = 0, match_fpga = 0;
unsigned char hash_cpu[32], hash_fpga[32];
unsigned char header_bytes[80];
unsigned char hash_expected[32];
char hash_string_cpu[65];
char hash_string_fpga[65];


unsigned char hex_to_byte(char a, char b) {
  unsigned char byte = 0;
  if (a >= '0' && a <= '9') byte |= (a - '0') << 4;
  else if (a >= 'a' && a <= 'f') byte |= (a - 'a' + 10) << 4;
  else if (a >= 'A' && a <= 'F') byte |= (a - 'A' + 10) << 4;

  if (b >= '0' && b <= '9') byte |= (b - '0');
  else if (b >= 'a' && b <= 'f') byte |= (b - 'a' + 10);
  else if (b >= 'A' && b <= 'F') byte |= (b - 'A' + 10);

  return byte;
}

void hex_string_to_bytes(const char *hex_str, unsigned char *bytes, int len) {
  for (int i = 0; i < len; i++) {
    bytes[i] = hex_to_byte(hex_str[i * 2], hex_str[i * 2 + 1]);
  }
}

void PS_Mining(const char *header_hex, const char *hash_real){
  hex_string_to_bytes(header_hex, header_bytes, 80);
  hex_string_to_bytes(hash_real, hash_expected, 32);

  for (int i = 0; i < 20; i++) {
    header[i] = ((uint32_t)header_bytes[i*4 + 0] << 0) |
                ((uint32_t)header_bytes[i*4 + 1] << 8) |
                ((uint32_t)header_bytes[i*4 + 2] << 16) |
                ((uint32_t)header_bytes[i*4 + 3] << 24);
  }

  XTime t1, t2;
  XTime_GetTime(&t1);
  sha256_top(header, hash_result);
  XTime_GetTime(&t2);

  nanos_cpu = (t2 - t1) * 1000000000ULL / COUNTS_PER_SECOND;
  hashrate_cpu = 1000000000ULL / nanos_cpu;

  for (int i = 0; i < 8; i++) {
    hash_cpu[i*4 + 0] = (hash_result[i] >> 0) & 0xFF;
    hash_cpu[i*4 + 1] = (hash_result[i] >> 8) & 0xFF;
    hash_cpu[i*4 + 2] = (hash_result[i] >> 16) & 0xFF;
    hash_cpu[i*4 + 3] = (hash_result[i] >> 24) & 0xFF;
  }

  match_cpu = 1;
  for (int i = 0; i < 32; i++) {
    if (hash_cpu[i] != hash_expected[i]) {
      match_cpu = 0;
      break;
    }
  }

  for (int i = 0; i < 32; i++) sprintf(&hash_string_cpu[i*2], "%02X", hash_cpu[i]);
}


void IP_Mining(const char *header_hex, const char *hash_real) {
  hex_string_to_bytes(header_hex, header_bytes, 80);
  hex_string_to_bytes(hash_real, hash_expected, 32);

  for (int i = 0; i < 20; i++) {
    header[i] = ((uint32_t)header_bytes[i*4 + 0] << 0) |
                ((uint32_t)header_bytes[i*4 + 1] << 8) |
                ((uint32_t)header_bytes[i*4 + 2] << 16) |
                ((uint32_t)header_bytes[i*4 + 3] << 24);
  }

  for (int i = 0; i < 20; i++) {
    Xil_Out32(REG_HEADER_BASE + i * 4, header[i]);
  }

  Xil_Out32(REG_CONTROL, 0x01);  				// start IP
  while ((Xil_In32(REG_CONTROL) & 0x2) == 0);   // espera ap_done

  for (int i = 0; i < 8; i++) {
    hash_result[i] = Xil_In32(REG_RESULT_BASE + i * 4);
  }

  for (int i = 0; i < 8; i++) {
    hash_fpga[i*4 + 0] = (hash_result[i] >> 0) & 0xFF;
    hash_fpga[i*4 + 1] = (hash_result[i] >> 8) & 0xFF;
    hash_fpga[i*4 + 2] = (hash_result[i] >> 16) & 0xFF;
    hash_fpga[i*4 + 3] = (hash_result[i] >> 24) & 0xFF;
  }

  match_fpga = 1;
  for (int i = 0; i < 32; i++) {
    if (hash_fpga[i] != hash_expected[i]) {
      match_fpga = 0;
      break;
    }
  }

  u32 cycles = Xil_In32(CYCLE_COUNT_READ);
  nanos_fpga = ((u64)cycles * 1000000000ULL) / CLOCK_HZ;
  hashrate_fpga = (nanos_fpga > 0) ? 1000000000ULL / nanos_fpga : 0;

  for (int i = 0; i < 32; i++) sprintf(&hash_string_fpga[i*2], "%02X", hash_fpga[i]);
}

void resultados(const char *hash_real) {
  char hash_cpu_be[65];  // string para hash em BE
  char hash_fpga_be[65]; // string para hash em BE

  // Inverte hash_cpu (LE -> BE)
  for (int i = 0; i < 32; i++) {
    sprintf(&hash_cpu_be[i * 2], "%02X", hash_cpu[31 - i]);
  }
  hash_cpu_be[64] = '\0'; // null terminator

  // Inverte hash_fpga (LE -> BE)
  for (int i = 0; i < 32; i++) {
    sprintf(&hash_fpga_be[i * 2], "%02X", hash_fpga[31 - i]);
  }
  hash_fpga_be[64] = '\0'; // null terminator


  xil_printf("\r\nIniciando Double SHA256 no CPU (Cortex-A53 arch:ARMv8-A)...");
  xil_printf("\r\nDouble Hash gerado (em LE): %s", hash_string_cpu);

  xil_printf("\r\n\nIniciando Double SHA256 no FPGA (Zynq UltraScale+ MPSoC ZCU104)...");
  xil_printf("\r\nDouble Hash gerado (em LE): %s", hash_string_fpga);

  xil_printf("\r\n\n--- COMPARATIVO ---");
  xil_printf("\r\nHash Final do bloco: %s", hash_real);
  xil_printf("\r\n[CPU]  corresponde ao esperado? %s", match_cpu ? "SIM" : "NAO");
  xil_printf("\r\n[FPGA] corresponde ao esperado? %s", match_fpga ? "SIM" : "NAO");

  xil_printf("\r\n\n--------- RESULTADOS: ---------");
  xil_printf("\r\n[CPU] Double Hash gerado (em BE): %s", hash_cpu_be);
  xil_printf("\r\n[CPU] Tempo de execucao (preciso): %llu.%09llu segundos (%llu ns)",
    nanos_cpu / 1000000000ULL, nanos_cpu % 1000000000ULL, nanos_cpu);
  xil_printf("\r\n[CPU] Hashrate (estimado) = (numero de hashes / tempo total): %llu H/s", hashrate_cpu);

  xil_printf("\r\n\n[FPGA] Double Hash gerado (em BE): %s", hash_fpga_be);
  xil_printf("\r\n[FPGA] Tempo de execucao (preciso): %llu.%09llu segundos (%llu ns)",
    nanos_fpga / 1000000000ULL, nanos_fpga % 1000000000ULL, nanos_fpga);
  xil_printf("\r\n[FPGA] Hashrate (estimado) = (numero de hashes / tempo total): %llu H/s", hashrate_fpga);

  xil_printf("\r\n\nGanho de aceleracao comparado (FPGA/CPU) ~ %llux\r\n", nanos_cpu / nanos_fpga);
}

int main() {
  char resposta;
  char header_input[161];
  char hash_input[65];
  const char *header_hex =
    "0100000050120119172a610421a6c3011dd330d9df07b63616c2cc1f1cd00200"
    "000000006657a9252aacd5c0b2940996ecff952228c3067cc38d4885efb5a4ac"
    "4247e9f337221b4d4c86041b0f2b5710";

  const char *hash_real =
    "06e533fd1ada86391f3f6c343204b0d278d4aaec1c0b20aa27ba030000000000";

  xil_printf("\r\n--------- TESTE DOUBLE SHA256 ---------");
  xil_printf("\r\n\n--- ENTRADA DE DADOS ---");
  xil_printf("\r\nHeader (hex) com nonce:\r\n%s\r\n", header_hex);

  // Execucao
  PS_Mining(header_hex, hash_real);
  IP_Mining(header_hex, hash_real);
  resultados(hash_real);

  // Pergunta se deseja novo teste
	xil_printf("\r\nDeseja testar outro bloco ao vivo? (s/n): ");
	while ((resposta = getchar()) == '\n'); // ignora ENTER

  if (resposta == 's' || resposta == 'S') {
	xil_printf("\r\n--- ENTRADA DE DADOS ---");
    xil_printf("\r\nInsira o header (hex) com nonce [160 caracteres]:\r\n");
    scanf("%160s", header_input);
    xil_printf("\r\nHeader (hex) com nonce:\r\n%s\r\n", header_input);
    xil_printf("\r\nInsira o hash esperado (LE, 64 caracteres):\r\n");
    scanf("%64s", hash_input);

    PS_Mining(header_input, hash_input);
    IP_Mining(header_input, hash_input);
    resultados(hash_input);
  }
  return 0;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Script Python mempool.py} \label{apendice:mempool_py}

\begin{lstlisting}[language=Python]
import requests
import hashlib
import struct
import hashlib

global height
height = 100000

def sha256(data): # Realiza o SHA256 localmente para comparacao
  return hashlib.sha256(data).digest()

def bits_to_target(bits):
  exponent = bits >> 24
  mantissa = bits & 0xffffff
  target = mantissa * (1 << (8 * (exponent - 3)))
  # Altere para little-endian para compatibilidade direta com C
  return target.to_bytes(32, byteorder='little')

def get_block_info(height):
  r = requests.get(f"https://mempool.space/api/block-height/{height}")
  block_hash = r.text.strip()
  r = requests.get(f"https://mempool.space/api/block/{block_hash}")
  b = r.json()

  return {
    "version": struct.pack("<L", b["version"]),
    "prev_hash": bytes.fromhex(b["previousblockhash"])[::-1],
    "merkle_root": bytes.fromhex(b["merkle_root"])[::-1],
    "timestamp": struct.pack("<L", b["timestamp"]),
    "bits": struct.pack("<L", b["bits"]),
    "nonce": struct.pack("<L", b["nonce"]),
    "bits_int": b["bits"],
    "nonce_int": b["nonce"],
    "block_hash": block_hash
  }

def mempool():
  global height
  b = get_block_info(height)

  version     = b["version"]
  prev_hash   = b["prev_hash"]
  merkle_root = b["merkle_root"]
  timestamp   = b["timestamp"]
  bits        = b["bits"]
  nonce       = b["nonce"]

  header = version + prev_hash + merkle_root + timestamp + bits + nonce

  print("Version: ", version.hex())
  print("Prev Block: ", prev_hash.hex())
  print("Merkle Root: ", merkle_root.hex())
  print("Timestamp: ", timestamp.hex())
  print("Bits: ", bits.hex())
  print("Nonce: ", nonce.hex())
  print("Header = version + prev_hash + merkle_root + timestamp + bits + nonce")

  print("----- BLOCK HEADER (80 bytes, LE, hex) -----")
  print(header.hex())

  # Double SHA256 para verificar o hash final, utilizando a lib  hashlib do Python
  first_hash_bytes = sha256(header)
  final_hash_bytes = sha256(first_hash_bytes)

  print("\n----- VERIFICACAO DO HASH FINAL (DO PYTHON) -----")
  print(f"Bloco numero: {height}")
  print(f"Double Hash Final (LE, Hexa): \t\t{final_hash_bytes.hex()}") # do python
  print(f"Double Hash Final (BE, Hexa invertido): {final_hash_bytes[::-1].hex()}") # do python
  print(f"Hash do Bloco (mempool.space): \t\t{b['block_hash']}") # do mempool.space

if __name__ == "__main__":
  mempool()
\end{lstlisting}



\end{apendicesenv}